{
  parserClass="brig.concord.el.parser.ElParser"
  parserUtilClass="brig.concord.el.parser.ElParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="El"
  psiImplClassSuffix="Impl"
  psiPackage="brig.concord.el.psi"
  psiImplPackage="brig.concord.el.psi.impl"

  elementTypeHolderClass="brig.concord.el.psi.ElTypes"
  elementTypeClass="brig.concord.el.psi.ElElementType"
  tokenTypeClass="brig.concord.el.psi.ElTokenType"

  // Expression hierarchy — collapse passthrough wrappers
  extends(".*Expr|literal|parenExpr|listLiteral|mapLiteral")=expression
  extends("stringLiteral")=literal

  // Suffix hierarchy — collapse ElSuffix wrapper
  extends("dotSuffix|bracketSuffix|callSuffix")=suffix

  tokens = [
    WHITE_SPACE          = 'regexp:\s+'
    INTEGER_LITERAL      = 'regexp:[0-9]+'
    FLOAT_LITERAL        = 'regexp:[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+'
    SINGLE_QUOTED_STRING = "regexp:'([^'\\\\]|\\\\.)*'"
    DOUBLE_QUOTED_STRING = 'regexp:"([^"\\\\]|\\\\.)*"'

    TRUE_KEYWORD         = 'true'
    FALSE_KEYWORD        = 'false'
    NULL_KEYWORD         = 'null'
    EMPTY_KEYWORD        = 'empty'
    NOT_KEYWORD          = 'not'
    AND_KEYWORD          = 'and'
    OR_KEYWORD           = 'or'
    DIV_KEYWORD          = 'div'
    MOD_KEYWORD          = 'mod'
    EQ_KEYWORD           = 'eq'
    NE_KEYWORD           = 'ne'
    LT_KEYWORD           = 'lt'
    GT_KEYWORD           = 'gt'
    LE_KEYWORD           = 'le'
    GE_KEYWORD           = 'ge'
    INSTANCEOF_KEYWORD   = 'instanceof'

    CONCAT               = '+='
    ARROW                = '->'
    EQ_OP                = '=='
    NE_OP                = '!='
    LE_OP                = '<='
    GE_OP                = '>='
    AND_OP               = '&&'
    OR_OP                = '||'
    PLUS                 = '+'
    MINUS                = '-'
    MULT                 = '*'
    DIV_OP               = '/'
    MOD_OP               = '%'
    ASSIGN               = '='
    LT_OP                = '<'
    GT_OP                = '>'
    NOT_OP               = '!'
    DOT                  = '.'
    COMMA                = ','
    COLON                = ':'
    SEMICOLON            = ';'
    QUESTION             = '?'
    LPAREN               = '('
    RPAREN               = ')'
    LBRACKET             = '['
    RBRACKET             = ']'
    LBRACE               = '{'
    RBRACE               = '}'
    IDENTIFIER           = 'regexp:[a-zA-Z_$#][a-zA-Z0-9_$]*'
  ]
}

// ---- Root ----
root ::= expression?

// ---- Semicolon sequence (EL 3.0) ----
expression ::= assignExpr (SEMICOLON assignExpr)*

// ---- Assignment / Lambda ----
// Handles: choice = rhs  (assignment)
//          choice -> rhs  (lambda, left side must be identifier(s))
//          (x, y) -> rhs  (lambda, parenExpr parsed permissively with commas)
assignExpr ::= choiceExpr (ASSIGN assignExpr | ARROW assignExpr)?

// ---- Ternary ----
choiceExpr ::= orExpr (QUESTION choiceExpr COLON choiceExpr)?

// ---- Logical ----
orExpr  ::= andExpr ((OR_OP | OR_KEYWORD) andExpr)*
andExpr ::= eqExpr ((AND_OP | AND_KEYWORD) eqExpr)*

// ---- Equality ----
eqExpr ::= relExpr ((EQ_OP | EQ_KEYWORD | NE_OP | NE_KEYWORD) relExpr)*

// ---- Comparison ----
relExpr ::= concatExpr ((LT_OP | LT_KEYWORD | GT_OP | GT_KEYWORD
           | LE_OP | LE_KEYWORD | GE_OP | GE_KEYWORD
           | INSTANCEOF_KEYWORD) concatExpr)*

// ---- String concatenation (EL 3.0) ----
concatExpr ::= addExpr (CONCAT addExpr)*

// ---- Arithmetic ----
addExpr ::= mulExpr ((PLUS | MINUS) mulExpr)*
mulExpr ::= unaryExpr ((MULT | DIV_OP | DIV_KEYWORD | MOD_OP | MOD_KEYWORD) unaryExpr)*

// ---- Unary ----
unaryExpr ::= prefixExpr | accessExpr
prefixExpr ::= (MINUS | NOT_OP | NOT_KEYWORD | EMPTY_KEYWORD) unaryExpr

// ---- Value + access chain ----
accessExpr ::= primaryExpr suffix*
suffix ::= dotSuffix | bracketSuffix | callSuffix
dotSuffix ::= DOT memberName argList? {pin=1}
bracketSuffix ::= LBRACKET expression RBRACKET argList? {pin=1}
callSuffix ::= argList

// ---- Primary expressions ----
primaryExpr ::= literal
  | parenExpr
  | listLiteral
  | mapLiteral
  | functionExpr
  | identifierExpr

identifierExpr ::= IDENTIFIER {mixin="brig.concord.el.psi.impl.ElIdentifierExprMixin"}

// Namespace function call: ns:func(args)
// Uses external lookahead to avoid COLON ambiguity with ternary/map
functionExpr ::= <<isFunctionCall>> IDENTIFIER COLON IDENTIFIER argList+ {pin=3}

// Permissive: (expr, expr, ...) allows both grouping and lambda param lists.
// Lambda params validated semantically — each must be a simple identifier.
parenExpr ::= LPAREN expression (COMMA expression)* RPAREN {pin=1}

// ---- Literals ----
literal ::= INTEGER_LITERAL
  | FLOAT_LITERAL
  | stringLiteral
  | TRUE_KEYWORD
  | FALSE_KEYWORD
  | NULL_KEYWORD

stringLiteral ::= SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING

// ---- Collection literals (EL 3.0) ----
listLiteral ::= LBRACKET [expression (COMMA expression)*] RBRACKET {pin=1}

// Map/Set literal. Without COLON in mapEntry it's a set element.
mapLiteral ::= LBRACE [mapEntry (COMMA mapEntry)*] RBRACE {pin=1}
mapEntry ::= expression (COLON expression)?

// ---- Method arguments ----
argList ::= LPAREN [expression (COMMA expression)*] RPAREN {pin=1}

// ---- Property name after DOT ----
// All keywords are valid as property names (e.g. obj.class, obj.empty)
memberName ::= IDENTIFIER
  | TRUE_KEYWORD | FALSE_KEYWORD | NULL_KEYWORD
  | EMPTY_KEYWORD | NOT_KEYWORD | AND_KEYWORD | OR_KEYWORD
  | DIV_KEYWORD | MOD_KEYWORD | EQ_KEYWORD | NE_KEYWORD
  | LT_KEYWORD | GT_KEYWORD | LE_KEYWORD | GE_KEYWORD
  | INSTANCEOF_KEYWORD
{mixin="brig.concord.el.psi.impl.ElMemberNameMixin"}
